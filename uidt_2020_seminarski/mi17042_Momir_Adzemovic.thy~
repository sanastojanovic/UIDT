theory mi17042_Momir_Adzemovic
  imports Main "HOL-Imperative_HOL.Array"
begin
(* Prvi deo Seminarskog *)
(* Zadatak:
  Neka je n prirodan broj. Ako su a i b prirodni brojevi vecii od 1 takvi
  da je a*b= 2*n-1, dokazati da je broj ab-(a-b)-1 oblika k*2^(2m), gde
  je k neparan prirodan, a m prirodan broj. 
*)        

theorem balkanska_matematicka_olimpijada_2001_prvi_zadatak:
  fixes n a c :: nat
  assumes "a > 1 \<and> b > 1 \<and> a*b = 2^n-1"
  (* Zbog simetricnost promenljivih a i b mozemo bez umanjenja opstosti
     da pretpostavimo sledece: "a \<ge> b" 
     Ova pretpostavka se uvodi zbog izraza a*b-(a-b)-1, jer
     u slucaju da je b > a vazi: "a-b = 0"
  *)
  assumes "a \<ge> b"
  shows "\<exists> k m ::nat . (odd k) \<and> (a*b-(a-b)-1 = k*2^m)"
  using assms
  sorry

(* Drugi Deo Seminarskog *)
(* Napomena: Ako se ne navede 'mâˆˆ{1..p}', program ne moze da izracuna izraz *)
definition prime :: "nat â‡’ bool"  where 
  "prime p â‰¡ 1 < p âˆ§ (âˆ€mâˆˆ{1..p}. m dvd p âŸ¶  m = 1 âˆ¨ m = p)"

definition true_factor :: "nat â‡’ nat â‡’ bool" where
  "true_factor x y â‰¡ x > 1 âˆ§ x < y âˆ§ x dvd y"

(* Svaki prost broj je veci ili jednak od 2 *)
lemma prime_greater_than_2[simp]:
  "prime x âŸ¶ x â‰¥ 2"
  by (simp add: prime_def)

value "prime 5"

(* 
  Ako broj p nije prost, onda postoji z, tako da vazi1 < z < p
  (pravi delilac) i z deli p 
*)
lemma not_prime_hence_has_true_factor:
  assumes "p > 1"
  assumes "Â¬ prime p"
  shows "âˆƒz. true_factor z p"
  using assms
proof-
  from â€¹Â¬ prime pâ€º have "p â‰¤ 1 âˆ¨ (âˆƒmâˆˆ{1..p}. m dvd p âˆ§ Â¬ (m = 1 âˆ¨ m = p))"
    unfolding prime_def
    using le_less_linear by blast
  hence "âˆƒmâˆˆ{1..p}. m dvd p âˆ§ Â¬ (m = 1 âˆ¨ m = p)"
    using â€¹p > 1â€º
    by auto
  hence "âˆƒmâˆˆ{1..p}. m dvd p âˆ§ m â‰  1 âˆ§ m â‰  p"
    by auto
  hence "âˆƒmâˆˆ{1..p}. m dvd p âˆ§ m > 1 âˆ§ m < p"
    by auto
  hence "âˆƒmâˆˆ{1..p}. true_factor m p"
    unfolding true_factor_def
    by auto
  thus ?thesis
    by auto
qed

lemma prime_is_product_of_two_true_factors:
  fixes p :: nat
  assumes "p > 1"
  assumes "\<not> prime p"
  shows "\<exists>a b. true_factor a p \<and> true_factor b p \<and> a*b = p"
proof-
  from assms have "\<exists>a. true_factor a p"
    by (simp add: not_prime_hence_has_true_factor)
  then obtain a where "true_factor a p"
    by auto
  hence "a < p"
    unfolding true_factor_def
    by auto
  hence "\<exists>b. a*b = p"
    using â€¹true_factor a pâ€º true_factor_def by auto
  thus ?thesis
    using â€¹true_factor a pâ€º true_factor_def by auto
qed

lemma test:
  fixes p :: nat
  shows "(p â‰¥ 2 âˆ§ p â‰¤ n âˆ§ Â¬ prime p) âŸ¶ (âˆƒz. prime z âˆ§ true_factor z p)"
proof (induction n)
  case 0
  then show ?case 
    by auto
next
  case (Suc n)
  then show ?case
  proof (cases "p < 2")
    case True
    then show ?thesis 
      using not_less by blast
  next
    case False
    then show ?thesis
    proof (cases "prime p")
      case True
      then show ?thesis
      by blast
    next
      case False
      then show ?thesis
      proof (cases "p = Suc n")
        case True
        then show ?thesis 
        proof-
          have "p > 1"
            using \<open>\<not> p < 2\<close>
            by auto
          hence "\<exists>a b. true_factor a p \<and> true_factor b p \<and> a*b = p"
            using \<open>\<not> prime p\<close>
            using prime_is_product_of_two_true_factors by blast
          then obtain a b where "true_factor a p \<and> true_factor b p \<and> a*b = p"
            by blast
          then show ?thesis
          proof (cases "prime a")
            case True
            then show ?thesis 
              using â€¹true_factor a p âˆ§ true_factor b p âˆ§ a * b = pâ€º by blast
          next
            case False
            hence "a \<le> n"
              using True â€¹true_factor a p âˆ§ true_factor b p âˆ§ a * b = pâ€º true_factor_def by auto
            hence "\<exists>c. prime c \<and> true_factor c a"
              sledgehammer
            then show ?thesis 
          qed
        qed
      next
        case False
        then show ?thesis 
          by (simp add: Suc.IH)
      qed
    qed    
  qed
qed


(* 
  Ako broj nije prost, onda ima prost delilac
  dokaz indukcijom, gde se pretpostavlja da vazi
  za sve brojeve manje od n
*)
lemma not_prime_hence_has_prime_true_factor:
  "âˆ€p. (p â‰¥ 2 âˆ§ p â‰¤ n âˆ§ Â¬ prime p) âŸ¶ (âˆƒz. prime z âˆ§ true_factor z p)"
proof (induction n)
  case 0
  then show ?case 
    by simp
next
  case (Suc n)      
  then show ?case    
  proof    
    show ?case    
      sorry
    fix p   
    assume "2 â‰¤ p âˆ§ p â‰¤ Suc n âˆ§ Â¬ prime p"  
    hence "âˆƒz. prime z âˆ§ true_factor z p"      
    proof                                         
      have "Â¬ prime p"
        by (simp add: â€¹2 â‰¤ p âˆ§ p â‰¤ Suc n âˆ§ Â¬ prime pâ€º)
      hence "âˆƒa. true_factor a p"
        using â€¹2 â‰¤ p âˆ§ p â‰¤ Suc n âˆ§ Â¬ prime pâ€º not_prime_hence_has_true_factor by auto
      then obtain a where "true_factor a p"
        by auto
      then show ?thesis
      proof (cases "prime a")
        case True
        then show ?thesis 
          using â€¹true_factor a pâ€º by blast
      next
        case False
        hence "a â‰¤ n" 
          using â€¹2 â‰¤ p âˆ§ p â‰¤ Suc n âˆ§ Â¬ prime pâ€º â€¹true_factor a pâ€º true_factor_def by auto
        hence "âˆƒb. prime b âˆ§ true_factor b a"
          using False Suc.IH â€¹true_factor a pâ€º true_factor_def by auto
        then obtain b where "prime b âˆ§ true_factor b a"
          by auto
        hence "true_factor b p"
          using â€¹true_factor a pâ€º less_trans true_factor_def by auto
        then show ?thesis 
          using â€¹prime b âˆ§ true_factor b aâ€º by blast
      qed
    qed
  qed
qed

(* funkcija koja izbacuje svoje mnozioce (sem sebe) *)
primrec remove_multipliers :: "nat list â‡’ nat â‡’ nat list" where
  "remove_multipliers [] n = []"
| "remove_multipliers (x # xs) n = (if n dvd x âˆ§ x > n
                                    then remove_multipliers xs n
                                    else x # (remove_multipliers xs n))"

(* lista prirodnih brojeva do n bez jedinice *)
definition nlist :: "nat â‡’ nat list" where
  "nlist n = rev [2..<n+1]"

value "remove_multipliers (nlist 100) 2"
value "remove_multipliers (nlist 1) 2"
value "remove_multipliers (nlist 2) 2"

lemma nlist_suc[simp]:
  assumes "n > 0"
  shows "nlist (Suc n) = (Suc n) # (nlist n)"
  unfolding nlist_def
  using assms
  by auto

lemma nlist_suc_subset[simp]:
 "set (nlist n) âŠ† set (nlist (Suc n))"
  unfolding nlist_def
  by auto 

lemma remove_multipliers_remove_y_stays:
  assumes "y âˆˆ set ys"
  shows "y âˆˆ set (remove_multipliers ys y)"
  using assms
  by (induction ys) auto

lemma remove_multipliers_subset[simp]:
  "set (remove_multipliers xs y) âŠ† set xs"
  by (induction xs) auto

lemma remove_multipliers_nlist_subset[simp]:
  "set (remove_multipliers (nlist n) y) âŠ† set (nlist n)"
  by auto

lemma remove_multipliers_big_y:
  assumes "y > n"
  shows "remove_multipliers (nlist n) y = nlist n"
  using assms
proof (induction n)
  case 0
  then show ?case
    unfolding nlist_def
    by auto
next
  case (Suc n)
  then show ?case
  proof (cases "n = 0")
    case True
    then show ?thesis
      unfolding nlist_def
      by auto
  next
    case False
    then show ?thesis
    proof-
      have "remove_multipliers (nlist (Suc n)) y
        = remove_multipliers ((Suc n) # (nlist n)) y"
        using â€¹n â‰  0â€º
        by auto
      also have "...  = (Suc n) # (remove_multipliers (nlist n) y)"
        using assms(1)
        by (simp add: Suc.prems nat_dvd_not_less)
      also have "... = (Suc n) # (nlist n)"
        by (simp add: Suc.IH Suc.prems Suc_lessD)
      also have "... = nlist (Suc n)"
        using False 
        by auto
      finally show ?thesis
        by simp
    qed
  qed  
qed

lemma remove_multipliers_nlist_suc_subset[simp]:
  "set (remove_multipliers (nlist n) y) 
    âŠ† set (remove_multipliers (nlist (Suc n)) y)"
proof (cases "n > 0")
  case True
  hence *: "remove_multipliers (nlist (Suc n)) y
        = remove_multipliers ((Suc n) # (nlist n)) y"
    by simp 

  case True
  then show ?thesis
  proof (cases "(Suc n) â‰¤ y")
    case True
    hence **: â€¹Â¬(y dvd (Suc n) âˆ§ (Suc n) > y)â€º
      by auto
    case True
    then show ?thesis
    proof-
      from * have "remove_multipliers (nlist (Suc n)) y 
            = remove_multipliers ((Suc n) # (nlist n)) y"
        by simp
      also have "... = (Suc n) # remove_multipliers (nlist n) y"
        using â€¹Â¬(y dvd (Suc n) âˆ§ (Suc n) > y)â€º
        by auto
      also have "set ((Suc n) # remove_multipliers (nlist n) y)
            = {Suc n} âˆª set (remove_multipliers (nlist n) y)"
        by auto
      finally have "set (remove_multipliers (nlist n) y)
                     âŠ† set (remove_multipliers (nlist (Suc n)) y)"
        by auto
      thus ?thesis
        by simp
    qed
  next
    case False
    then show ?thesis
    proof (cases "y dvd (Suc n)")
      case True
      hence ***: â€¹y dvd (Suc n) âˆ§ (Suc n) > yâ€º
        using â€¹Â¬ (Suc n â‰¤ y)â€º
        by auto
        case True
      then show ?thesis
      proof-
        from * have "remove_multipliers (nlist (Suc n)) y 
              = remove_multipliers ((Suc n) # (nlist n)) y"
          by simp
        also have "... = remove_multipliers (nlist n) y"
          using â€¹y dvd (Suc n) âˆ§ (Suc n) > yâ€º
          by simp
        finally have "set (remove_multipliers (nlist n) y)
                     âŠ† set (remove_multipliers (nlist (Suc n)) y)"
        by simp
      thus  ?thesis
          by simp
      qed
    next
      case False
      hence **: â€¹Â¬(y dvd (Suc n) âˆ§ (Suc n) > y)â€º
        by auto
      case False
      then show ?thesis
      proof-
      from * have "remove_multipliers (nlist (Suc n)) y 
            = remove_multipliers ((Suc n) # (nlist n)) y"
        by simp
      also have "... = (Suc n) # remove_multipliers (nlist n) y"
        using â€¹Â¬(y dvd (Suc n) âˆ§ (Suc n) > y)â€º
        by auto
      also have "set ((Suc n) # remove_multipliers (nlist n) y)
            = {Suc n} âˆª set (remove_multipliers (nlist n) y)"
        by auto
      finally have "set (remove_multipliers (nlist n) y)
                     âŠ† set (remove_multipliers (nlist (Suc n)) y)"
        by auto
      thus ?thesis
        by simp
      qed
    qed
  qed
next
  case False 
  then show ?thesis
    unfolding nlist_def
    by auto
qed

lemma remove_multipliers_suc_subset[simp]:
  "set (remove_multipliers (nlist (Suc n)) y)
   âŠ† {Suc n} âˆª (set (remove_multipliers (nlist n) y))"
  unfolding nlist_def
  by auto

theorem remove_multipliers_theorem1:
  fixes x y n :: nat
  assumes "y â‰¥ 2"
  assumes "x â‰¤ n âˆ§ x > y"
  shows "x âˆˆ set (remove_multipliers (nlist n) y) âŸ· Â¬ (y dvd x)"
  using assms
proof (induction n)
  case 0
  then show ?case
    by auto
next
  case (Suc n) 
  then show ?case 
  proof (cases "x = Suc n")
    case True
    then show ?thesis
    proof (cases "y dvd Suc n")
      case True
      then show ?thesis 
      proof-
        have "remove_multipliers (nlist (Suc n)) y
          = remove_multipliers ((Suc n) # (nlist n)) y"
          by (metis One_nat_def True assms(1) dvd_imp_le neq0_conv nlist_suc not_less_eq_eq one_add_one plus_1_eq_Suc zero_less_Suc)
        hence "... = remove_multipliers (nlist n) y"
          using Suc.prems(2) True by auto
        have "(Suc n) âˆ‰ set (remove_multipliers (nlist n) y)"
          by (metis Groups.add_ac(2) Suc_n_not_le_n atLeastAtMost_iff atLeastLessThanSuc_atLeastAtMost in_mono nlist_def one_add_one plus_1_eq_Suc remove_multipliers_subset set_rev set_upt)
        hence "x âˆ‰ set (remove_multipliers (nlist n) y)"
          using â€¹x = Suc nâ€º
          by blast
        hence "x âˆ‰ set (remove_multipliers (nlist (Suc n)) y)"
          using â€¹remove_multipliers (Suc n # nlist n) y = remove_multipliers (nlist n) yâ€º â€¹remove_multipliers (nlist (Suc n)) y = remove_multipliers (Suc n # nlist n) yâ€º 
          by auto
        show ?thesis
          using Suc.IH Suc.prems(2) True â€¹x âˆ‰ set (remove_multipliers (nlist (Suc n)) y)â€º â€¹x âˆ‰ set (remove_multipliers (nlist n) y)â€º assms(1) le_Suc_eq by blast
    qed
    next
      case False
      then show ?thesis 
      proof-
        have "remove_multipliers (nlist (Suc n)) y
          = remove_multipliers ((Suc n) # (nlist n)) y"
          using Suc.prems(2) assms(1) by auto
        hence "... = (Suc n) # remove_multipliers (nlist n) y"
          by (simp add: False)
        have "(Suc n) âˆˆ set ((Suc n) # remove_multipliers (nlist n) y)"
          by simp
        hence "x âˆˆ set ((Suc n) # remove_multipliers (nlist n) y)"
          using True 
          by blast
        hence "x âˆˆ set (remove_multipliers (nlist (Suc n)) y)"
          using â€¹remove_multipliers (Suc n # nlist n) y = Suc n # remove_multipliers (nlist n) yâ€º â€¹remove_multipliers (nlist (Suc n)) y = remove_multipliers (Suc n # nlist n) yâ€º 
          by auto
        thus ?thesis
          using False True by blast
      qed
    qed
  next
    case False
    hence *: "x âˆˆ set (remove_multipliers (nlist n) y) âŸ· Â¬ (y dvd x)"
      using Suc.IH Suc.prems(2) assms(1) le_SucE by blast
    have "set (remove_multipliers (nlist (Suc n)) y)
        âŠ† {Suc n} âˆª (set (remove_multipliers (nlist n) y))"
      using remove_multipliers_suc_subset by simp
    hence "x âˆˆ set (remove_multipliers (nlist (Suc n)) y)
        âŸ¶ x = (Suc n) âˆ¨ x âˆˆ set (remove_multipliers (nlist n) y)"
      by auto
    from this and â€¹x â‰  Suc nâ€º have **: 
       "x âˆˆ set (remove_multipliers (nlist (Suc n)) y)
        âŸ¶ x âˆˆ set (remove_multipliers (nlist n) y)"
      by auto
    case False
    then show ?thesis
      using â€¹x â‰  Suc nâ€º
      using * and **
      using remove_multipliers_nlist_suc_subset 
      by blast
  qed
qed

theorem remove_multipliers_theorem1_cons:
  fixes x y n :: nat
  assumes "y â‰¥ 2"
  assumes "x â‰¤ n âˆ§ x > y"
  shows "prime x âŸ¶ x âˆˆ set (remove_multipliers (nlist n) y)"
  using assms
  using prime_def remove_multipliers_theorem1 by auto

theorem remove_multipliers_theorem2:
  assumes "prime x"
  assumes "x âˆˆ set xs"
  assumes "x â‰  y"
  assumes "y â‰¥ 2"
  shows "x âˆˆ set (remove_multipliers xs y)"
  using assms
proof (induction xs)
  case Nil
  then show ?case 
    by simp
next
  case (Cons a xs)
  then show ?case
  proof (cases "a > y")
    case True
    then show ?thesis
    proof (cases "y dvd a")
      case True
      then show ?thesis
      proof-
        from â€¹a > yâ€º and â€¹y dvd aâ€º have "y dvd a âˆ§ a > y"
          by simp
        hence "remove_multipliers (a # xs) y = remove_multipliers xs y"
          by auto
        also have â€¹x âˆˆ set (remove_multipliers xs y)â€º 
          by (metis Cons.IH Cons.prems(2) True â€¹y < aâ€º â€¹y dvd a âˆ§ y < aâ€º assms(1) assms(3) assms(4) less_imp_triv not_less remove_multipliers_theorem1 remove_multipliers_theorem1_cons set_ConsD)
        finally show ?thesis
          by simp
      qed
    next
      case False
      then show ?thesis 
        using Cons.IH Cons.prems(2) assms(1) assms(3) assms(4) by auto
    qed
  next
    case False
    then show ?thesis 
      using Cons.IH Cons.prems(2) assms(1) assms(3) assms(4) by auto
  qed
qed

lemma remove_multipliers_true_factor:
  assumes "true_factor z y"
  shows "y âˆ‰ set (remove_multipliers xs z)"
  using assms
proof (induction xs)
  case Nil
  then show ?case
    by auto
next
  case (Cons a xs)
  then show ?case
  proof (cases "a = y")
    case True
    then show ?thesis
      using Cons.IH assms true_factor_def by auto
  next
    case False
    then show ?thesis 
      using Cons.IH assms by auto
  qed
qed

(* Erastostenovo Sito *)
primrec erast' :: "nat list â‡’ nat list â‡’ nat list" where
  "erast' [] ys = ys"
| "erast' (x # xs) ys = (let es = erast' xs ys
                         in (if x âˆˆ set es
                             then remove_multipliers es x
                             else es))"

definition erast :: "nat â‡’ nat list" where
  "erast n = rev (erast' (nlist n) (nlist n))"

value "erast 100"

lemma erast_0:
  "erast 0 = []"
  unfolding erast_def nlist_def
  by auto

lemma erast'_next_sub:
  "set (erast' (x # xs) ys) âŠ† set (erast' xs ys)"
proof (cases "x âˆˆ set (erast' xs ys)")
  case True
  then show ?thesis
  proof-
    have "erast' (x # xs) ys = remove_multipliers (erast' xs ys) x"
      using True
      by auto
    hence "set (erast' (x # xs) ys) âŠ† set (remove_multipliers (erast' xs ys) x)"
      by auto
    thus "set (erast' (x # xs) ys) âŠ† set (erast' xs ys)"
      using remove_multipliers_subset
      by blast
  qed
next
  case False
  then show ?thesis
    by auto
qed

lemma erast'_nlist_sub:
  "set (erast' xs ys) âŠ† set ys"
proof (induction xs)
  case Nil
  then show ?case
    by auto
next
  case (Cons a xs)
  then show ?case
    by (meson dual_order.trans erast'_next_sub)
qed

lemma erast_nlist_sub:
  "set (erast n) âŠ† set (nlist n)"
  unfolding erast_def
  by (simp add: erast'_nlist_sub)

lemma erast'_prime_stays:
  assumes "prime y"
  assumes "y âˆˆ set ys"
  shows "y âˆˆ set (erast' (nlist n) ys)"
proof (induction n)
  case 0
  then show ?case
    unfolding nlist_def
    by (simp add: assms(2))
next
  case (Suc n)
  then show ?case
  proof (cases "n = 0")
    case True
    then show ?thesis
      unfolding nlist_def
      by (simp add: assms(2))
  next
    case False
    hence *: "erast' (nlist (Suc n)) ys = erast' ((Suc n) # (nlist n)) ys"
      by simp
    case False
    then show ?thesis 
    proof (cases "(Suc n) âˆˆ set (erast' (nlist n) ys)")
      case True
      from this and * have **: "erast' (nlist (Suc n)) ys = 
        remove_multipliers (erast' (nlist n) ys) (Suc n)"
        by simp

      case True
      then show ?thesis
      proof (cases "y = Suc n")
        case True
        then show ?thesis
        proof-
          from â€¹y = Suc nâ€º and â€¹y âˆˆ set (erast' (nlist n) ys)â€º have 
            "y âˆˆ set (remove_multipliers (erast' (nlist n) ys) (Suc n))"
            using remove_multipliers_remove_y_stays 
            by simp
          from this and ** show ?thesis
            by simp
        qed
      next
        case False
        then show ?thesis
          using "**" Suc.IH assms(1) nlist_def remove_multipliers_theorem2 by fastforce
      qed
    next
      case False
      hence "erast' (nlist (Suc n)) ys = erast' (nlist n) ys"
        by (simp add: "*")

      case False
      then show ?thesis 
        by (simp add: Suc.IH â€¹erast' (nlist (Suc n)) ys = erast' (nlist n) ysâ€º)
    qed
  qed
qed

theorem erast_prime_stays:
  assumes "prime y"
  assumes "y â‰¤ n"
  shows "y âˆˆ set (erast n)" 
  using assms
proof (induction n)
case 0
  then show ?case 
    using prime_def by blast
next
  case (Suc n)
  then show ?case
  proof-
    have "y âˆˆ set (nlist (Suc n))"
      by (metis (full_types) One_nat_def Suc.IH Suc.prems(2) assms(1) erast_nlist_sub le_SucE list.set_intros(1) nat_less_le nlist_suc nlist_suc_subset prime_def subset_eq zero_less_Suc)
    hence "y âˆˆ set (erast' (nlist (Suc n)) (nlist (Suc n)))"
      using assms(1) erast'_prime_stays by blast
    thus "y âˆˆ set (erast (Suc n))"
      by (simp add: erast_def)
  qed
qed

lemma erast'_less_than_n:
  assumes "y âˆˆ set (erast' (nlist n) (nlist n))"
  shows "y â‰¤ n"
  using assms erast'_nlist_sub nlist_def by fastforce

lemma erast_y_less_than_n:
  assumes "y âˆˆ set (erast' (nlist n) (nlist n))"
  shows "y > 1 âˆ§ y â‰¤ n"
proof-
  from assms have "y âˆˆ set (nlist n)"
    using erast'_nlist_sub by blast
  thus "y > 1 âˆ§ y â‰¤ n"
    using nlist_def
    by auto
qed

lemma erast'_less_removals_sub:
  shows "set(erast' (cs @ as) ys) âŠ† set(erast' as ys)"
proof (induction cs)
  case Nil
  then show ?case
    by simp
next
  case (Cons c cs)
  then show ?case 
  proof (cases "c âˆˆ set(erast' (cs @ as) ys)")
    case True
    then show ?thesis
      by (metis Cons.IH append_Cons dual_order.trans erast'_next_sub)
  next
    case False
    then show ?thesis 
      using Cons.IH by auto
  qed

qed

lemma erast_prime_true_factor_deletes:
  assumes "prime z"
  assumes "true_factor z y"
  assumes "y â‰¤ n"
  shows "y âˆ‰ set (erast n)"
  using assms
proof-
  have "z âˆˆ set (nlist n)"
    by (meson assms(1) assms(2) assms(3) erast_nlist_sub erast_prime_stays less_imp_le_nat less_le_trans subset_iff true_factor_def)
  hence "z âˆˆ set (erast n)"
    using assms(1) assms(2) assms(3) erast_prime_stays true_factor_def by auto
  from â€¹z âˆˆ set (nlist n)â€º have "âˆƒas bs. (nlist n) = as @ [z] @ bs"
    by (simp add: split_list)
  then obtain as bs where "(nlist n) = as @ [z] @ bs"
    by auto
  hence "set ([z] @ bs) âŠ† set (as @ [z] @ bs)"
    by (simp add: subset_iff)
  have "set (erast' (nlist n) (nlist n)) = set(erast' (as @ [z] @ bs) (nlist n))"
    using â€¹nlist n = as @ [z] @ bsâ€º by auto
  hence "... âŠ† set(erast' ([z] @ bs) (nlist n))"
    using erast'_less_removals_sub by blast
  have "z âˆˆ set(erast' bs (nlist n))"
    by (metis Cons_eq_appendI â€¹nlist n = as @ [z] @ bsâ€º â€¹set (erast' (as @ [z] @ bs) (nlist n)) âŠ† set (erast' ([z] @ bs) (nlist n))â€º â€¹z âˆˆ set (nlist n)â€º append_self_conv2 assms(1) erast'_next_sub erast'_prime_stays in_mono)
  hence "erast' ([z] @ bs) (nlist n)
     = remove_multipliers (erast' bs (nlist n)) z"
    by auto
  hence "y âˆ‰ set (remove_multipliers (erast' bs (nlist n)) z)"
    using assms(2) remove_multipliers_true_factor by blast
  hence "y âˆ‰ set (erast' ([z] @ bs) (nlist n))"
    using â€¹erast' ([z] @ bs) (nlist n) = remove_multipliers (erast' bs (nlist n)) zâ€º by auto
  thus "y âˆ‰ set (erast n)"
    using â€¹nlist n = as @ [z] @ bsâ€º â€¹set (erast' (as @ [z] @ bs) (nlist n)) âŠ† set (erast' ([z] @ bs) (nlist n))â€º erast_def by auto
qed

lemma erast_true_factor_deletes:
  assumes "true_factor z y"
  assumes "y â‰¤ n"
  shows "y âˆ‰ set (erast n)"
  using assms
proof (cases "prime z")
  case True
  then show ?thesis 
    using assms(1) assms(2) erast_prime_true_factor_deletes by blast
next
  case False
  hence "âˆƒs. true_factor s z âˆ§ prime s"
    by (metis (full_types) One_nat_def Suc_1 Suc_leI assms(1) le_refl not_prime_hence_has_prime_true_factor true_factor_def)
 then obtain s where "true_factor s z âˆ§ prime s"
    by auto
  hence "true_factor s y"
    using assms(1) less_trans true_factor_def by auto
  then show ?thesis
    using â€¹true_factor s z âˆ§ prime sâ€º assms(2) erast_prime_true_factor_deletes by blast
qed


lemma erast'_keeps_prime:
  assumes "y â‰¤ n"
  assumes "y âˆˆ set (erast' (nlist n) (nlist n))"
  shows "prime y"
  apply (rule ccontr)
proof-
  assume "Â¬ prime y"
  then show False
  proof-
    from â€¹Â¬ prime yâ€º have "âˆƒz. true_factor z y"
      unfolding true_factor_def
      by (metis assms(2) atLeastAtMost_iff dual_order.order_iff_strict erast_y_less_than_n prime_def)
    then obtain z where "true_factor z y"
      by auto
    hence "z âˆˆ set (nlist n)"
      unfolding true_factor_def
      using assms(1) nlist_def by auto
    hence "y âˆ‰ set (erast' (nlist n) (nlist n))"
      using true_factor_def
      using â€¹true_factor z yâ€º assms(1) erast_def erast_true_factor_deletes by auto
    from this and assms show "False"
      by auto
  qed
qed

theorem erast_keeps_prime:
  assumes "y âˆˆ set (erast n)"
  shows "prime y"
  using assms erast'_keeps_prime erast_def erast_y_less_than_n by auto

theorem erast_prime:
  fixes x n :: nat
  assumes "x â‰¤ n"
  shows "x âˆˆ set (erast n) âŸ· prime x"
  using assms
  using erast_keeps_prime erast_prime_stays by blast

end